{"version":3,"file":"adm-zip.js","sources":["../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/util/constants.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/util/errors.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/util/utils.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/util/fattr.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/util/decoder.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/util/index.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/headers/entryHeader.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/headers/mainHeader.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/headers/index.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/methods/deflater.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/methods/inflater.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/methods/zipcrypto.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/methods/index.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/zipEntry.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/zipFile.js","../node_modules/.pnpm/adm-zip@0.5.16/node_modules/adm-zip/adm-zip.js"],"sourcesContent":["module.exports = {\n    /* The local file header */\n    LOCHDR           : 30, // LOC header size\n    LOCSIG           : 0x04034b50, // \"PK\\003\\004\"\n    LOCVER           : 4,\t// version needed to extract\n    LOCFLG           : 6, // general purpose bit flag\n    LOCHOW           : 8, // compression method\n    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)\n    LOCCRC           : 14, // uncompressed file crc-32 value\n    LOCSIZ           : 18, // compressed size\n    LOCLEN           : 22, // uncompressed size\n    LOCNAM           : 26, // filename length\n    LOCEXT           : 28, // extra field length\n\n    /* The Data descriptor */\n    EXTSIG           : 0x08074b50, // \"PK\\007\\008\"\n    EXTHDR           : 16, // EXT header size\n    EXTCRC           : 4, // uncompressed file crc-32 value\n    EXTSIZ           : 8, // compressed size\n    EXTLEN           : 12, // uncompressed size\n\n    /* The central directory file header */\n    CENHDR           : 46, // CEN header size\n    CENSIG           : 0x02014b50, // \"PK\\001\\002\"\n    CENVEM           : 4, // version made by\n    CENVER           : 6, // version needed to extract\n    CENFLG           : 8, // encrypt, decrypt flags\n    CENHOW           : 10, // compression method\n    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)\n    CENCRC           : 16, // uncompressed file crc-32 value\n    CENSIZ           : 20, // compressed size\n    CENLEN           : 24, // uncompressed size\n    CENNAM           : 28, // filename length\n    CENEXT           : 30, // extra field length\n    CENCOM           : 32, // file comment length\n    CENDSK           : 34, // volume number start\n    CENATT           : 36, // internal file attributes\n    CENATX           : 38, // external file attributes (host system dependent)\n    CENOFF           : 42, // LOC header offset\n\n    /* The entries in the end of central directory */\n    ENDHDR           : 22, // END header size\n    ENDSIG           : 0x06054b50, // \"PK\\005\\006\"\n    ENDSUB           : 8, // number of entries on this disk\n    ENDTOT           : 10, // total number of entries\n    ENDSIZ           : 12, // central directory size in bytes\n    ENDOFF           : 16, // offset of first CEN header\n    ENDCOM           : 20, // zip file comment length\n\n    END64HDR         : 20, // zip64 END header size\n    END64SIG         : 0x07064b50, // zip64 Locator signature, \"PK\\006\\007\"\n    END64START       : 4, // number of the disk with the start of the zip64\n    END64OFF         : 8, // relative offset of the zip64 end of central directory\n    END64NUMDISKS    : 16, // total number of disks\n\n    ZIP64SIG         : 0x06064b50, // zip64 signature, \"PK\\006\\006\"\n    ZIP64HDR         : 56, // zip64 record minimum size\n    ZIP64LEAD        : 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE\n    ZIP64SIZE        : 4, // zip64 size of the central directory record\n    ZIP64VEM         : 12, // zip64 version made by\n    ZIP64VER         : 14, // zip64 version needed to extract\n    ZIP64DSK         : 16, // zip64 number of this disk\n    ZIP64DSKDIR      : 20, // number of the disk with the start of the record directory\n    ZIP64SUB         : 24, // number of entries on this disk\n    ZIP64TOT         : 32, // total number of entries\n    ZIP64SIZB        : 40, // zip64 central directory size in bytes\n    ZIP64OFF         : 48, // offset of start of central directory with respect to the starting disk number\n    ZIP64EXTRA       : 56, // extensible data sector\n\n    /* Compression methods */\n    STORED           : 0, // no compression\n    SHRUNK           : 1, // shrunk\n    REDUCED1         : 2, // reduced with compression factor 1\n    REDUCED2         : 3, // reduced with compression factor 2\n    REDUCED3         : 4, // reduced with compression factor 3\n    REDUCED4         : 5, // reduced with compression factor 4\n    IMPLODED         : 6, // imploded\n    // 7 reserved for Tokenizing compression algorithm\n    DEFLATED         : 8, // deflated\n    ENHANCED_DEFLATED: 9, // enhanced deflated\n    PKWARE           : 10,// PKWare DCL imploded\n    // 11 reserved by PKWARE\n    BZIP2            : 12, //  compressed using BZIP2\n    // 13 reserved by PKWARE\n    LZMA             : 14, // LZMA\n    // 15-17 reserved by PKWARE\n    IBM_TERSE        : 18, // compressed using IBM TERSE\n    IBM_LZ77         : 19, // IBM LZ77 z\n    AES_ENCRYPT      : 99, // WinZIP AES encryption method\n\n    /* General purpose bit flag */\n    // values can obtained with expression 2**bitnr\n    FLG_ENC          : 1,    // Bit 0: encrypted file\n    FLG_COMP1        : 2,    // Bit 1, compression option\n    FLG_COMP2        : 4,    // Bit 2, compression option\n    FLG_DESC         : 8,    // Bit 3, data descriptor\n    FLG_ENH          : 16,   // Bit 4, enhanced deflating\n    FLG_PATCH        : 32,   // Bit 5, indicates that the file is compressed patched data.\n    FLG_STR          : 64,   // Bit 6, strong encryption (patented)\n                             // Bits 7-10: Currently unused.\n    FLG_EFS          : 2048, // Bit 11: Language encoding flag (EFS)\n                             // Bit 12: Reserved by PKWARE for enhanced compression.\n                             // Bit 13: encrypted the Central Directory (patented).\n                             // Bits 14-15: Reserved by PKWARE.\n    FLG_MSK          : 4096, // mask header values\n\n    /* Load type */\n    FILE             : 2,\n    BUFFER           : 1,\n    NONE             : 0,\n\n    /* 4.5 Extensible data fields */\n    EF_ID            : 0,\n    EF_SIZE          : 2,\n\n    /* Header IDs */\n    ID_ZIP64         : 0x0001,\n    ID_AVINFO        : 0x0007,\n    ID_PFS           : 0x0008,\n    ID_OS2           : 0x0009,\n    ID_NTFS          : 0x000a,\n    ID_OPENVMS       : 0x000c,\n    ID_UNIX          : 0x000d,\n    ID_FORK          : 0x000e,\n    ID_PATCH         : 0x000f,\n    ID_X509_PKCS7    : 0x0014,\n    ID_X509_CERTID_F : 0x0015,\n    ID_X509_CERTID_C : 0x0016,\n    ID_STRONGENC     : 0x0017,\n    ID_RECORD_MGT    : 0x0018,\n    ID_X509_PKCS7_RL : 0x0019,\n    ID_IBM1          : 0x0065,\n    ID_IBM2          : 0x0066,\n    ID_POSZIP        : 0x4690,\n\n    EF_ZIP64_OR_32   : 0xffffffff,\n    EF_ZIP64_OR_16   : 0xffff,\n    EF_ZIP64_SUNCOMP : 0,\n    EF_ZIP64_SCOMP   : 8,\n    EF_ZIP64_RHO     : 16,\n    EF_ZIP64_DSN     : 24\n};\n","const errors = {\n    /* Header error messages */\n    INVALID_LOC: \"Invalid LOC header (bad signature)\",\n    INVALID_CEN: \"Invalid CEN header (bad signature)\",\n    INVALID_END: \"Invalid END header (bad signature)\",\n\n    /* Descriptor */\n    DESCRIPTOR_NOT_EXIST: \"No descriptor present\",\n    DESCRIPTOR_UNKNOWN: \"Unknown descriptor format\",\n    DESCRIPTOR_FAULTY: \"Descriptor data is malformed\",\n\n    /* ZipEntry error messages*/\n    NO_DATA: \"Nothing to decompress\",\n    BAD_CRC: \"CRC32 checksum failed {0}\",\n    FILE_IN_THE_WAY: \"There is a file in the way: {0}\",\n    UNKNOWN_METHOD: \"Invalid/unsupported compression method\",\n\n    /* Inflater error messages */\n    AVAIL_DATA: \"inflate::Available inflate data did not terminate\",\n    INVALID_DISTANCE: \"inflate::Invalid literal/length or distance code in fixed or dynamic block\",\n    TO_MANY_CODES: \"inflate::Dynamic block code description: too many length or distance codes\",\n    INVALID_REPEAT_LEN: \"inflate::Dynamic block code description: repeat more than specified lengths\",\n    INVALID_REPEAT_FIRST: \"inflate::Dynamic block code description: repeat lengths with no first length\",\n    INCOMPLETE_CODES: \"inflate::Dynamic block code description: code lengths codes incomplete\",\n    INVALID_DYN_DISTANCE: \"inflate::Dynamic block code description: invalid distance code lengths\",\n    INVALID_CODES_LEN: \"inflate::Dynamic block code description: invalid literal/length code lengths\",\n    INVALID_STORE_BLOCK: \"inflate::Stored block length did not match one's complement\",\n    INVALID_BLOCK_TYPE: \"inflate::Invalid block type (type == 3)\",\n\n    /* ADM-ZIP error messages */\n    CANT_EXTRACT_FILE: \"Could not extract the file\",\n    CANT_OVERRIDE: \"Target file already exists\",\n    DISK_ENTRY_TOO_LARGE: \"Number of disk entries is too large\",\n    NO_ZIP: \"No zip file was loaded\",\n    NO_ENTRY: \"Entry doesn't exist\",\n    DIRECTORY_CONTENT_ERROR: \"A directory cannot have content\",\n    FILE_NOT_FOUND: 'File not found: \"{0}\"',\n    NOT_IMPLEMENTED: \"Not implemented\",\n    INVALID_FILENAME: \"Invalid filename\",\n    INVALID_FORMAT: \"Invalid or unsupported zip format. No END header found\",\n    INVALID_PASS_PARAM: \"Incompatible password parameter\",\n    WRONG_PASSWORD: \"Wrong Password\",\n\n    /* ADM-ZIP */\n    COMMENT_TOO_LONG: \"Comment is too long\", // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)\n    EXTRA_FIELD_PARSE_ERROR: \"Extra field parsing error\"\n};\n\n// template\nfunction E(message) {\n    return function (...args) {\n        if (args.length) { // Allow {0} .. {9} arguments in error message, based on argument number\n            message = message.replace(/\\{(\\d)\\}/g, (_, n) => args[n] || '');\n        }\n\n        return new Error('ADM-ZIP: ' + message);\n    };\n}\n\n// Init errors with template\nfor (const msg of Object.keys(errors)) {\n    exports[msg] = E(errors[msg]);\n}\n","const fsystem = require(\"fs\");\nconst pth = require(\"path\");\nconst Constants = require(\"./constants\");\nconst Errors = require(\"./errors\");\nconst isWin = typeof process === \"object\" && \"win32\" === process.platform;\n\nconst is_Obj = (obj) => typeof obj === \"object\" && obj !== null;\n\n// generate CRC32 lookup table\nconst crcTable = new Uint32Array(256).map((t, c) => {\n    for (let k = 0; k < 8; k++) {\n        if ((c & 1) !== 0) {\n            c = 0xedb88320 ^ (c >>> 1);\n        } else {\n            c >>>= 1;\n        }\n    }\n    return c >>> 0;\n});\n\n// UTILS functions\n\nfunction Utils(opts) {\n    this.sep = pth.sep;\n    this.fs = fsystem;\n\n    if (is_Obj(opts)) {\n        // custom filesystem\n        if (is_Obj(opts.fs) && typeof opts.fs.statSync === \"function\") {\n            this.fs = opts.fs;\n        }\n    }\n}\n\nmodule.exports = Utils;\n\n// INSTANTIABLE functions\n\nUtils.prototype.makeDir = function (/*String*/ folder) {\n    const self = this;\n\n    // Sync - make directories tree\n    function mkdirSync(/*String*/ fpath) {\n        let resolvedPath = fpath.split(self.sep)[0];\n        fpath.split(self.sep).forEach(function (name) {\n            if (!name || name.substr(-1, 1) === \":\") return;\n            resolvedPath += self.sep + name;\n            var stat;\n            try {\n                stat = self.fs.statSync(resolvedPath);\n            } catch (e) {\n                self.fs.mkdirSync(resolvedPath);\n            }\n            if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY(`\"${resolvedPath}\"`);\n        });\n    }\n\n    mkdirSync(folder);\n};\n\nUtils.prototype.writeFileTo = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {\n    const self = this;\n    if (self.fs.existsSync(path)) {\n        if (!overwrite) return false; // cannot overwrite\n\n        var stat = self.fs.statSync(path);\n        if (stat.isDirectory()) {\n            return false;\n        }\n    }\n    var folder = pth.dirname(path);\n    if (!self.fs.existsSync(folder)) {\n        self.makeDir(folder);\n    }\n\n    var fd;\n    try {\n        fd = self.fs.openSync(path, \"w\", 0o666); // 0666\n    } catch (e) {\n        self.fs.chmodSync(path, 0o666);\n        fd = self.fs.openSync(path, \"w\", 0o666);\n    }\n    if (fd) {\n        try {\n            self.fs.writeSync(fd, content, 0, content.length, 0);\n        } finally {\n            self.fs.closeSync(fd);\n        }\n    }\n    self.fs.chmodSync(path, attr || 0o666);\n    return true;\n};\n\nUtils.prototype.writeFileToAsync = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {\n    if (typeof attr === \"function\") {\n        callback = attr;\n        attr = undefined;\n    }\n\n    const self = this;\n\n    self.fs.exists(path, function (exist) {\n        if (exist && !overwrite) return callback(false);\n\n        self.fs.stat(path, function (err, stat) {\n            if (exist && stat.isDirectory()) {\n                return callback(false);\n            }\n\n            var folder = pth.dirname(path);\n            self.fs.exists(folder, function (exists) {\n                if (!exists) self.makeDir(folder);\n\n                self.fs.open(path, \"w\", 0o666, function (err, fd) {\n                    if (err) {\n                        self.fs.chmod(path, 0o666, function () {\n                            self.fs.open(path, \"w\", 0o666, function (err, fd) {\n                                self.fs.write(fd, content, 0, content.length, 0, function () {\n                                    self.fs.close(fd, function () {\n                                        self.fs.chmod(path, attr || 0o666, function () {\n                                            callback(true);\n                                        });\n                                    });\n                                });\n                            });\n                        });\n                    } else if (fd) {\n                        self.fs.write(fd, content, 0, content.length, 0, function () {\n                            self.fs.close(fd, function () {\n                                self.fs.chmod(path, attr || 0o666, function () {\n                                    callback(true);\n                                });\n                            });\n                        });\n                    } else {\n                        self.fs.chmod(path, attr || 0o666, function () {\n                            callback(true);\n                        });\n                    }\n                });\n            });\n        });\n    });\n};\n\nUtils.prototype.findFiles = function (/*String*/ path) {\n    const self = this;\n\n    function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {\n        if (typeof pattern === \"boolean\") {\n            recursive = pattern;\n            pattern = undefined;\n        }\n        let files = [];\n        self.fs.readdirSync(dir).forEach(function (file) {\n            const path = pth.join(dir, file);\n            const stat = self.fs.statSync(path);\n\n            if (!pattern || pattern.test(path)) {\n                files.push(pth.normalize(path) + (stat.isDirectory() ? self.sep : \"\"));\n            }\n\n            if (stat.isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));\n        });\n        return files;\n    }\n\n    return findSync(path, undefined, true);\n};\n\n/**\n * Callback for showing if everything was done.\n *\n * @callback filelistCallback\n * @param {Error} err - Error object\n * @param {string[]} list - was request fully completed\n */\n\n/**\n *\n * @param {string} dir\n * @param {filelistCallback} cb\n */\nUtils.prototype.findFilesAsync = function (dir, cb) {\n    const self = this;\n    let results = [];\n    self.fs.readdir(dir, function (err, list) {\n        if (err) return cb(err);\n        let list_length = list.length;\n        if (!list_length) return cb(null, results);\n        list.forEach(function (file) {\n            file = pth.join(dir, file);\n            self.fs.stat(file, function (err, stat) {\n                if (err) return cb(err);\n                if (stat) {\n                    results.push(pth.normalize(file) + (stat.isDirectory() ? self.sep : \"\"));\n                    if (stat.isDirectory()) {\n                        self.findFilesAsync(file, function (err, res) {\n                            if (err) return cb(err);\n                            results = results.concat(res);\n                            if (!--list_length) cb(null, results);\n                        });\n                    } else {\n                        if (!--list_length) cb(null, results);\n                    }\n                }\n            });\n        });\n    });\n};\n\nUtils.prototype.getAttributes = function () {};\n\nUtils.prototype.setAttributes = function () {};\n\n// STATIC functions\n\n// crc32 single update (it is part of crc32)\nUtils.crc32update = function (crc, byte) {\n    return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);\n};\n\nUtils.crc32 = function (buf) {\n    if (typeof buf === \"string\") {\n        buf = Buffer.from(buf, \"utf8\");\n    }\n\n    let len = buf.length;\n    let crc = ~0;\n    for (let off = 0; off < len; ) crc = Utils.crc32update(crc, buf[off++]);\n    // xor and cast as uint32 number\n    return ~crc >>> 0;\n};\n\nUtils.methodToString = function (/*Number*/ method) {\n    switch (method) {\n        case Constants.STORED:\n            return \"STORED (\" + method + \")\";\n        case Constants.DEFLATED:\n            return \"DEFLATED (\" + method + \")\";\n        default:\n            return \"UNSUPPORTED (\" + method + \")\";\n    }\n};\n\n/**\n * removes \"..\" style path elements\n * @param {string} path - fixable path\n * @returns string - fixed filepath\n */\nUtils.canonical = function (/*string*/ path) {\n    if (!path) return \"\";\n    // trick normalize think path is absolute\n    const safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n    return pth.join(\".\", safeSuffix);\n};\n\n/**\n * fix file names in achive\n * @param {string} path - fixable path\n * @returns string - fixed filepath\n */\n\nUtils.zipnamefix = function (path) {\n    if (!path) return \"\";\n    // trick normalize think path is absolute\n    const safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n    return pth.posix.join(\".\", safeSuffix);\n};\n\n/**\n *\n * @param {Array} arr\n * @param {function} callback\n * @returns\n */\nUtils.findLast = function (arr, callback) {\n    if (!Array.isArray(arr)) throw new TypeError(\"arr is not array\");\n\n    const len = arr.length >>> 0;\n    for (let i = len - 1; i >= 0; i--) {\n        if (callback(arr[i], i, arr)) {\n            return arr[i];\n        }\n    }\n    return void 0;\n};\n\n// make abolute paths taking prefix as root folder\nUtils.sanitize = function (/*string*/ prefix, /*string*/ name) {\n    prefix = pth.resolve(pth.normalize(prefix));\n    var parts = name.split(\"/\");\n    for (var i = 0, l = parts.length; i < l; i++) {\n        var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n        if (path.indexOf(prefix) === 0) {\n            return path;\n        }\n    }\n    return pth.normalize(pth.join(prefix, pth.basename(name)));\n};\n\n// converts buffer, Uint8Array, string types to buffer\nUtils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input, /* function */ encoder) {\n    if (Buffer.isBuffer(input)) {\n        return input;\n    } else if (input instanceof Uint8Array) {\n        return Buffer.from(input);\n    } else {\n        // expect string all other values are invalid and return empty buffer\n        return typeof input === \"string\" ? encoder(input) : Buffer.alloc(0);\n    }\n};\n\nUtils.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {\n    var slice = Buffer.from(buffer.slice(index, index + 8));\n    slice.swap64();\n\n    return parseInt(`0x${slice.toString(\"hex\")}`);\n};\n\nUtils.fromDOS2Date = function (val) {\n    return new Date(((val >> 25) & 0x7f) + 1980, Math.max(((val >> 21) & 0x0f) - 1, 0), Math.max((val >> 16) & 0x1f, 1), (val >> 11) & 0x1f, (val >> 5) & 0x3f, (val & 0x1f) << 1);\n};\n\nUtils.fromDate2DOS = function (val) {\n    let date = 0;\n    let time = 0;\n    if (val.getFullYear() > 1979) {\n        date = (((val.getFullYear() - 1980) & 0x7f) << 9) | ((val.getMonth() + 1) << 5) | val.getDate();\n        time = (val.getHours() << 11) | (val.getMinutes() << 5) | (val.getSeconds() >> 1);\n    }\n    return (date << 16) | time;\n};\n\nUtils.isWin = isWin; // Do we have windows system\nUtils.crcTable = crcTable;\n","const pth = require(\"path\");\n\nmodule.exports = function (/*String*/ path, /*Utils object*/ { fs }) {\n    var _path = path || \"\",\n        _obj = newAttr(),\n        _stat = null;\n\n    function newAttr() {\n        return {\n            directory: false,\n            readonly: false,\n            hidden: false,\n            executable: false,\n            mtime: 0,\n            atime: 0\n        };\n    }\n\n    if (_path && fs.existsSync(_path)) {\n        _stat = fs.statSync(_path);\n        _obj.directory = _stat.isDirectory();\n        _obj.mtime = _stat.mtime;\n        _obj.atime = _stat.atime;\n        _obj.executable = (0o111 & _stat.mode) !== 0; // file is executable who ever har right not just owner\n        _obj.readonly = (0o200 & _stat.mode) === 0; // readonly if owner has no write right\n        _obj.hidden = pth.basename(_path)[0] === \".\";\n    } else {\n        console.warn(\"Invalid path: \" + _path);\n    }\n\n    return {\n        get directory() {\n            return _obj.directory;\n        },\n\n        get readOnly() {\n            return _obj.readonly;\n        },\n\n        get hidden() {\n            return _obj.hidden;\n        },\n\n        get mtime() {\n            return _obj.mtime;\n        },\n\n        get atime() {\n            return _obj.atime;\n        },\n\n        get executable() {\n            return _obj.executable;\n        },\n\n        decodeAttributes: function () {},\n\n        encodeAttributes: function () {},\n\n        toJSON: function () {\n            return {\n                path: _path,\n                isDirectory: _obj.directory,\n                isReadOnly: _obj.readonly,\n                isHidden: _obj.hidden,\n                isExecutable: _obj.executable,\n                mTime: _obj.mtime,\n                aTime: _obj.atime\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n","module.exports = {\n    efs: true,\n    encode: (data) => Buffer.from(data, \"utf8\"),\n    decode: (data) => data.toString(\"utf8\")\n};\n","module.exports = require(\"./utils\");\nmodule.exports.Constants = require(\"./constants\");\nmodule.exports.Errors = require(\"./errors\");\nmodule.exports.FileAttr = require(\"./fattr\");\nmodule.exports.decoder = require(\"./decoder\");\n","var Utils = require(\"../util\"),\n    Constants = Utils.Constants;\n\n/* The central directory file header */\nmodule.exports = function () {\n    var _verMade = 20, // v2.0\n        _version = 10, // v1.0\n        _flags = 0,\n        _method = 0,\n        _time = 0,\n        _crc = 0,\n        _compressedSize = 0,\n        _size = 0,\n        _fnameLen = 0,\n        _extraLen = 0,\n        _comLen = 0,\n        _diskStart = 0,\n        _inattr = 0,\n        _attr = 0,\n        _offset = 0;\n\n    _verMade |= Utils.isWin ? 0x0a00 : 0x0300;\n\n    // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.\n    // Without it file names may be corrupted for other apps when file names use unicode chars\n    _flags |= Constants.FLG_EFS;\n\n    const _localHeader = {\n        extraLen: 0\n    };\n\n    // casting\n    const uint32 = (val) => Math.max(0, val) >>> 0;\n    const uint16 = (val) => Math.max(0, val) & 0xffff;\n    const uint8 = (val) => Math.max(0, val) & 0xff;\n\n    _time = Utils.fromDate2DOS(new Date());\n\n    return {\n        get made() {\n            return _verMade;\n        },\n        set made(val) {\n            _verMade = val;\n        },\n\n        get version() {\n            return _version;\n        },\n        set version(val) {\n            _version = val;\n        },\n\n        get flags() {\n            return _flags;\n        },\n        set flags(val) {\n            _flags = val;\n        },\n\n        get flags_efs() {\n            return (_flags & Constants.FLG_EFS) > 0;\n        },\n        set flags_efs(val) {\n            if (val) {\n                _flags |= Constants.FLG_EFS;\n            } else {\n                _flags &= ~Constants.FLG_EFS;\n            }\n        },\n\n        get flags_desc() {\n            return (_flags & Constants.FLG_DESC) > 0;\n        },\n        set flags_desc(val) {\n            if (val) {\n                _flags |= Constants.FLG_DESC;\n            } else {\n                _flags &= ~Constants.FLG_DESC;\n            }\n        },\n\n        get method() {\n            return _method;\n        },\n        set method(val) {\n            switch (val) {\n                case Constants.STORED:\n                    this.version = 10;\n                case Constants.DEFLATED:\n                default:\n                    this.version = 20;\n            }\n            _method = val;\n        },\n\n        get time() {\n            return Utils.fromDOS2Date(this.timeval);\n        },\n        set time(val) {\n            this.timeval = Utils.fromDate2DOS(val);\n        },\n\n        get timeval() {\n            return _time;\n        },\n        set timeval(val) {\n            _time = uint32(val);\n        },\n\n        get timeHighByte() {\n            return uint8(_time >>> 8);\n        },\n        get crc() {\n            return _crc;\n        },\n        set crc(val) {\n            _crc = uint32(val);\n        },\n\n        get compressedSize() {\n            return _compressedSize;\n        },\n        set compressedSize(val) {\n            _compressedSize = uint32(val);\n        },\n\n        get size() {\n            return _size;\n        },\n        set size(val) {\n            _size = uint32(val);\n        },\n\n        get fileNameLength() {\n            return _fnameLen;\n        },\n        set fileNameLength(val) {\n            _fnameLen = val;\n        },\n\n        get extraLength() {\n            return _extraLen;\n        },\n        set extraLength(val) {\n            _extraLen = val;\n        },\n\n        get extraLocalLength() {\n            return _localHeader.extraLen;\n        },\n        set extraLocalLength(val) {\n            _localHeader.extraLen = val;\n        },\n\n        get commentLength() {\n            return _comLen;\n        },\n        set commentLength(val) {\n            _comLen = val;\n        },\n\n        get diskNumStart() {\n            return _diskStart;\n        },\n        set diskNumStart(val) {\n            _diskStart = uint32(val);\n        },\n\n        get inAttr() {\n            return _inattr;\n        },\n        set inAttr(val) {\n            _inattr = uint32(val);\n        },\n\n        get attr() {\n            return _attr;\n        },\n        set attr(val) {\n            _attr = uint32(val);\n        },\n\n        // get Unix file permissions\n        get fileAttr() {\n            return (_attr || 0) >> 16 & 0xfff;\n        },\n\n        get offset() {\n            return _offset;\n        },\n        set offset(val) {\n            _offset = uint32(val);\n        },\n\n        get encrypted() {\n            return (_flags & Constants.FLG_ENC) === Constants.FLG_ENC;\n        },\n\n        get centralHeaderSize() {\n            return Constants.CENHDR + _fnameLen + _extraLen + _comLen;\n        },\n\n        get realDataOffset() {\n            return _offset + Constants.LOCHDR + _localHeader.fnameLen + _localHeader.extraLen;\n        },\n\n        get localHeader() {\n            return _localHeader;\n        },\n\n        loadLocalHeaderFromBinary: function (/*Buffer*/ input) {\n            var data = input.slice(_offset, _offset + Constants.LOCHDR);\n            // 30 bytes and should start with \"PK\\003\\004\"\n            if (data.readUInt32LE(0) !== Constants.LOCSIG) {\n                throw Utils.Errors.INVALID_LOC();\n            }\n\n            // version needed to extract\n            _localHeader.version = data.readUInt16LE(Constants.LOCVER);\n            // general purpose bit flag\n            _localHeader.flags = data.readUInt16LE(Constants.LOCFLG);\n            // compression method\n            _localHeader.method = data.readUInt16LE(Constants.LOCHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            _localHeader.time = data.readUInt32LE(Constants.LOCTIM);\n            // uncompressed file crc-32 valu\n            _localHeader.crc = data.readUInt32LE(Constants.LOCCRC);\n            // compressed size\n            _localHeader.compressedSize = data.readUInt32LE(Constants.LOCSIZ);\n            // uncompressed size\n            _localHeader.size = data.readUInt32LE(Constants.LOCLEN);\n            // filename length\n            _localHeader.fnameLen = data.readUInt16LE(Constants.LOCNAM);\n            // extra field length\n            _localHeader.extraLen = data.readUInt16LE(Constants.LOCEXT);\n\n            // read extra data\n            const extraStart = _offset + Constants.LOCHDR + _localHeader.fnameLen;\n            const extraEnd = extraStart + _localHeader.extraLen;\n            return input.slice(extraStart, extraEnd);\n        },\n\n        loadFromBinary: function (/*Buffer*/ data) {\n            // data should be 46 bytes and start with \"PK 01 02\"\n            if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {\n                throw Utils.Errors.INVALID_CEN();\n            }\n            // version made by\n            _verMade = data.readUInt16LE(Constants.CENVEM);\n            // version needed to extract\n            _version = data.readUInt16LE(Constants.CENVER);\n            // encrypt, decrypt flags\n            _flags = data.readUInt16LE(Constants.CENFLG);\n            // compression method\n            _method = data.readUInt16LE(Constants.CENHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            _time = data.readUInt32LE(Constants.CENTIM);\n            // uncompressed file crc-32 value\n            _crc = data.readUInt32LE(Constants.CENCRC);\n            // compressed size\n            _compressedSize = data.readUInt32LE(Constants.CENSIZ);\n            // uncompressed size\n            _size = data.readUInt32LE(Constants.CENLEN);\n            // filename length\n            _fnameLen = data.readUInt16LE(Constants.CENNAM);\n            // extra field length\n            _extraLen = data.readUInt16LE(Constants.CENEXT);\n            // file comment length\n            _comLen = data.readUInt16LE(Constants.CENCOM);\n            // volume number start\n            _diskStart = data.readUInt16LE(Constants.CENDSK);\n            // internal file attributes\n            _inattr = data.readUInt16LE(Constants.CENATT);\n            // external file attributes\n            _attr = data.readUInt32LE(Constants.CENATX);\n            // LOC header offset\n            _offset = data.readUInt32LE(Constants.CENOFF);\n        },\n\n        localHeaderToBinary: function () {\n            // LOC header size (30 bytes)\n            var data = Buffer.alloc(Constants.LOCHDR);\n            // \"PK\\003\\004\"\n            data.writeUInt32LE(Constants.LOCSIG, 0);\n            // version needed to extract\n            data.writeUInt16LE(_version, Constants.LOCVER);\n            // general purpose bit flag\n            data.writeUInt16LE(_flags, Constants.LOCFLG);\n            // compression method\n            data.writeUInt16LE(_method, Constants.LOCHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            data.writeUInt32LE(_time, Constants.LOCTIM);\n            // uncompressed file crc-32 value\n            data.writeUInt32LE(_crc, Constants.LOCCRC);\n            // compressed size\n            data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);\n            // uncompressed size\n            data.writeUInt32LE(_size, Constants.LOCLEN);\n            // filename length\n            data.writeUInt16LE(_fnameLen, Constants.LOCNAM);\n            // extra field length\n            data.writeUInt16LE(_localHeader.extraLen, Constants.LOCEXT);\n            return data;\n        },\n\n        centralHeaderToBinary: function () {\n            // CEN header size (46 bytes)\n            var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);\n            // \"PK\\001\\002\"\n            data.writeUInt32LE(Constants.CENSIG, 0);\n            // version made by\n            data.writeUInt16LE(_verMade, Constants.CENVEM);\n            // version needed to extract\n            data.writeUInt16LE(_version, Constants.CENVER);\n            // encrypt, decrypt flags\n            data.writeUInt16LE(_flags, Constants.CENFLG);\n            // compression method\n            data.writeUInt16LE(_method, Constants.CENHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            data.writeUInt32LE(_time, Constants.CENTIM);\n            // uncompressed file crc-32 value\n            data.writeUInt32LE(_crc, Constants.CENCRC);\n            // compressed size\n            data.writeUInt32LE(_compressedSize, Constants.CENSIZ);\n            // uncompressed size\n            data.writeUInt32LE(_size, Constants.CENLEN);\n            // filename length\n            data.writeUInt16LE(_fnameLen, Constants.CENNAM);\n            // extra field length\n            data.writeUInt16LE(_extraLen, Constants.CENEXT);\n            // file comment length\n            data.writeUInt16LE(_comLen, Constants.CENCOM);\n            // volume number start\n            data.writeUInt16LE(_diskStart, Constants.CENDSK);\n            // internal file attributes\n            data.writeUInt16LE(_inattr, Constants.CENATT);\n            // external file attributes\n            data.writeUInt32LE(_attr, Constants.CENATX);\n            // LOC header offset\n            data.writeUInt32LE(_offset, Constants.CENOFF);\n            return data;\n        },\n\n        toJSON: function () {\n            const bytes = function (nr) {\n                return nr + \" bytes\";\n            };\n\n            return {\n                made: _verMade,\n                version: _version,\n                flags: _flags,\n                method: Utils.methodToString(_method),\n                time: this.time,\n                crc: \"0x\" + _crc.toString(16).toUpperCase(),\n                compressedSize: bytes(_compressedSize),\n                size: bytes(_size),\n                fileNameLength: bytes(_fnameLen),\n                extraLength: bytes(_extraLen),\n                commentLength: bytes(_comLen),\n                diskNumStart: _diskStart,\n                inAttr: _inattr,\n                attr: _attr,\n                offset: _offset,\n                centralHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n","var Utils = require(\"../util\"),\n    Constants = Utils.Constants;\n\n/* The entries in the end of central directory */\nmodule.exports = function () {\n    var _volumeEntries = 0,\n        _totalEntries = 0,\n        _size = 0,\n        _offset = 0,\n        _commentLength = 0;\n\n    return {\n        get diskEntries() {\n            return _volumeEntries;\n        },\n        set diskEntries(/*Number*/ val) {\n            _volumeEntries = _totalEntries = val;\n        },\n\n        get totalEntries() {\n            return _totalEntries;\n        },\n        set totalEntries(/*Number*/ val) {\n            _totalEntries = _volumeEntries = val;\n        },\n\n        get size() {\n            return _size;\n        },\n        set size(/*Number*/ val) {\n            _size = val;\n        },\n\n        get offset() {\n            return _offset;\n        },\n        set offset(/*Number*/ val) {\n            _offset = val;\n        },\n\n        get commentLength() {\n            return _commentLength;\n        },\n        set commentLength(/*Number*/ val) {\n            _commentLength = val;\n        },\n\n        get mainHeaderSize() {\n            return Constants.ENDHDR + _commentLength;\n        },\n\n        loadFromBinary: function (/*Buffer*/ data) {\n            // data should be 22 bytes and start with \"PK 05 06\"\n            // or be 56+ bytes and start with \"PK 06 06\" for Zip64\n            if (\n                (data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) &&\n                (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)\n            ) {\n                throw Utils.Errors.INVALID_END();\n            }\n\n            if (data.readUInt32LE(0) === Constants.ENDSIG) {\n                // number of entries on this volume\n                _volumeEntries = data.readUInt16LE(Constants.ENDSUB);\n                // total number of entries\n                _totalEntries = data.readUInt16LE(Constants.ENDTOT);\n                // central directory size in bytes\n                _size = data.readUInt32LE(Constants.ENDSIZ);\n                // offset of first CEN header\n                _offset = data.readUInt32LE(Constants.ENDOFF);\n                // zip file comment length\n                _commentLength = data.readUInt16LE(Constants.ENDCOM);\n            } else {\n                // number of entries on this volume\n                _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);\n                // total number of entries\n                _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);\n                // central directory size in bytes\n                _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);\n                // offset of first CEN header\n                _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);\n\n                _commentLength = 0;\n            }\n        },\n\n        toBinary: function () {\n            var b = Buffer.alloc(Constants.ENDHDR + _commentLength);\n            // \"PK 05 06\" signature\n            b.writeUInt32LE(Constants.ENDSIG, 0);\n            b.writeUInt32LE(0, 4);\n            // number of entries on this volume\n            b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);\n            // total number of entries\n            b.writeUInt16LE(_totalEntries, Constants.ENDTOT);\n            // central directory size in bytes\n            b.writeUInt32LE(_size, Constants.ENDSIZ);\n            // offset of first CEN header\n            b.writeUInt32LE(_offset, Constants.ENDOFF);\n            // zip file comment length\n            b.writeUInt16LE(_commentLength, Constants.ENDCOM);\n            // fill comment memory with spaces so no garbage is left there\n            b.fill(\" \", Constants.ENDHDR);\n\n            return b;\n        },\n\n        toJSON: function () {\n            // creates 0x0000 style output\n            const offset = function (nr, len) {\n                let offs = nr.toString(16).toUpperCase();\n                while (offs.length < len) offs = \"0\" + offs;\n                return \"0x\" + offs;\n            };\n\n            return {\n                diskEntries: _volumeEntries,\n                totalEntries: _totalEntries,\n                size: _size + \" bytes\",\n                offset: offset(_offset, 4),\n                commentLength: _commentLength\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n// Misspelled\n","exports.EntryHeader = require(\"./entryHeader\");\nexports.MainHeader = require(\"./mainHeader\");\n","module.exports = function (/*Buffer*/ inbuf) {\n    var zlib = require(\"zlib\");\n\n    var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };\n\n    return {\n        deflate: function () {\n            return zlib.deflateRawSync(inbuf, opts);\n        },\n\n        deflateAsync: function (/*Function*/ callback) {\n            var tmp = zlib.createDeflateRaw(opts),\n                parts = [],\n                total = 0;\n            tmp.on(\"data\", function (data) {\n                parts.push(data);\n                total += data.length;\n            });\n            tmp.on(\"end\", function () {\n                var buf = Buffer.alloc(total),\n                    written = 0;\n                buf.fill(0);\n                for (var i = 0; i < parts.length; i++) {\n                    var part = parts[i];\n                    part.copy(buf, written);\n                    written += part.length;\n                }\n                callback && callback(buf);\n            });\n            tmp.end(inbuf);\n        }\n    };\n};\n","const version = +(process.versions ? process.versions.node : \"\").split(\".\")[0] || 0;\n\nmodule.exports = function (/*Buffer*/ inbuf, /*number*/ expectedLength) {\n    var zlib = require(\"zlib\");\n    const option = version >= 15 && expectedLength > 0 ? { maxOutputLength: expectedLength } : {};\n\n    return {\n        inflate: function () {\n            return zlib.inflateRawSync(inbuf, option);\n        },\n\n        inflateAsync: function (/*Function*/ callback) {\n            var tmp = zlib.createInflateRaw(option),\n                parts = [],\n                total = 0;\n            tmp.on(\"data\", function (data) {\n                parts.push(data);\n                total += data.length;\n            });\n            tmp.on(\"end\", function () {\n                var buf = Buffer.alloc(total),\n                    written = 0;\n                buf.fill(0);\n                for (var i = 0; i < parts.length; i++) {\n                    var part = parts[i];\n                    part.copy(buf, written);\n                    written += part.length;\n                }\n                callback && callback(buf);\n            });\n            tmp.end(inbuf);\n        }\n    };\n};\n","\"use strict\";\n\n// node crypt, we use it for generate salt\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { randomFillSync } = require(\"crypto\");\nconst Errors = require(\"../util/errors\");\n\n// generate CRC32 lookup table\nconst crctable = new Uint32Array(256).map((t, crc) => {\n    for (let j = 0; j < 8; j++) {\n        if (0 !== (crc & 1)) {\n            crc = (crc >>> 1) ^ 0xedb88320;\n        } else {\n            crc >>>= 1;\n        }\n    }\n    return crc >>> 0;\n});\n\n// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)\nconst uMul = (a, b) => Math.imul(a, b) >>> 0;\n\n// crc32 byte single update (actually same function is part of utils.crc32 function :) )\nconst crc32update = (pCrc32, bval) => {\n    return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);\n};\n\n// function for generating salt for encrytion header\nconst genSalt = () => {\n    if (\"function\" === typeof randomFillSync) {\n        return randomFillSync(Buffer.alloc(12));\n    } else {\n        // fallback if function is not defined\n        return genSalt.node();\n    }\n};\n\n// salt generation with node random function (mainly as fallback)\ngenSalt.node = () => {\n    const salt = Buffer.alloc(12);\n    const len = salt.length;\n    for (let i = 0; i < len; i++) salt[i] = (Math.random() * 256) & 0xff;\n    return salt;\n};\n\n// general config\nconst config = {\n    genSalt\n};\n\n// Class Initkeys handles same basic ops with keys\nfunction Initkeys(pw) {\n    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);\n    this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);\n    for (let i = 0; i < pass.length; i++) {\n        this.updateKeys(pass[i]);\n    }\n}\n\nInitkeys.prototype.updateKeys = function (byteValue) {\n    const keys = this.keys;\n    keys[0] = crc32update(keys[0], byteValue);\n    keys[1] += keys[0] & 0xff;\n    keys[1] = uMul(keys[1], 134775813) + 1;\n    keys[2] = crc32update(keys[2], keys[1] >>> 24);\n    return byteValue;\n};\n\nInitkeys.prototype.next = function () {\n    const k = (this.keys[2] | 2) >>> 0; // key\n    return (uMul(k, k ^ 1) >> 8) & 0xff; // decode\n};\n\nfunction make_decrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n\n    // return decrypter function\n    return function (/*Buffer*/ data) {\n        // result - we create new Buffer for results\n        const result = Buffer.alloc(data.length);\n        let pos = 0;\n        // process input data\n        for (let c of data) {\n            //c ^= keys.next();\n            //result[pos++] = c; // decode & Save Value\n            result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte\n        }\n        return result;\n    };\n}\n\nfunction make_encrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n\n    // return encrypting function, result and pos is here so we dont have to merge buffers later\n    return function (/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {\n        // result - we create new Buffer for results\n        if (!result) result = Buffer.alloc(data.length);\n        // process input data\n        for (let c of data) {\n            const k = keys.next(); // save key byte\n            result[pos++] = c ^ k; // save val\n            keys.updateKeys(c); // update keys with decoded byte\n        }\n        return result;\n    };\n}\n\nfunction decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {\n    if (!data || !Buffer.isBuffer(data) || data.length < 12) {\n        return Buffer.alloc(0);\n    }\n\n    // 1. We Initialize and generate decrypting function\n    const decrypter = make_decrypter(pwd);\n\n    // 2. decrypt salt what is always 12 bytes and is a part of file content\n    const salt = decrypter(data.slice(0, 12));\n\n    // if bit 3 (0x08) of the general-purpose flags field is set, check salt[11] with the high byte of the header time\n    // 2 byte data block (as per Info-Zip spec), otherwise check with the high byte of the header entry\n    const verifyByte = (header.flags & 0x8) === 0x8 ? header.timeHighByte : header.crc >>> 24;\n\n    //3. does password meet expectations\n    if (salt[11] !== verifyByte) {\n        throw Errors.WRONG_PASSWORD();\n    }\n\n    // 4. decode content\n    return decrypter(data.slice(12));\n}\n\n// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality\nfunction _salter(data) {\n    if (Buffer.isBuffer(data) && data.length >= 12) {\n        // be aware - currently salting buffer data is modified\n        config.genSalt = function () {\n            return data.slice(0, 12);\n        };\n    } else if (data === \"node\") {\n        // test salt generation with node random function\n        config.genSalt = genSalt.node;\n    } else {\n        // if value is not acceptable config gets reset.\n        config.genSalt = genSalt;\n    }\n}\n\nfunction encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {\n    // 1. test data if data is not Buffer we make buffer from it\n    if (data == null) data = Buffer.alloc(0);\n    // if data is not buffer be make buffer from it\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());\n\n    // 2. We Initialize and generate encrypting function\n    const encrypter = make_encrypter(pwd);\n\n    // 3. generate salt (12-bytes of random data)\n    const salt = config.genSalt();\n    salt[11] = (header.crc >>> 24) & 0xff;\n\n    // old implementations (before PKZip 2.04g) used two byte check\n    if (oldlike) salt[10] = (header.crc >>> 16) & 0xff;\n\n    // 4. create output\n    const result = Buffer.alloc(data.length + 12);\n    encrypter(salt, result);\n\n    // finally encode content\n    return encrypter(data, result, 12);\n}\n\nmodule.exports = { decrypt, encrypt, _salter };\n","exports.Deflater = require(\"./deflater\");\nexports.Inflater = require(\"./inflater\");\nexports.ZipCrypto = require(\"./zipcrypto\");\n","var Utils = require(\"./util\"),\n    Headers = require(\"./headers\"),\n    Constants = Utils.Constants,\n    Methods = require(\"./methods\");\n\nmodule.exports = function (/** object */ options, /*Buffer*/ input) {\n    var _centralHeader = new Headers.EntryHeader(),\n        _entryName = Buffer.alloc(0),\n        _comment = Buffer.alloc(0),\n        _isDirectory = false,\n        uncompressedData = null,\n        _extra = Buffer.alloc(0),\n        _extralocal = Buffer.alloc(0),\n        _efs = true;\n\n    // assign options\n    const opts = options;\n\n    const decoder = typeof opts.decoder === \"object\" ? opts.decoder : Utils.decoder;\n    _efs = decoder.hasOwnProperty(\"efs\") ? decoder.efs : false;\n\n    function getCompressedDataFromZip() {\n        //if (!input || !Buffer.isBuffer(input)) {\n        if (!input || !(input instanceof Uint8Array)) {\n            return Buffer.alloc(0);\n        }\n        _extralocal = _centralHeader.loadLocalHeaderFromBinary(input);\n        return input.slice(_centralHeader.realDataOffset, _centralHeader.realDataOffset + _centralHeader.compressedSize);\n    }\n\n    function crc32OK(data) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the local header is written\n        if (!_centralHeader.flags_desc) {\n            if (Utils.crc32(data) !== _centralHeader.localHeader.crc) {\n                return false;\n            }\n        } else {\n            const descriptor = {};\n            const dataEndOffset = _centralHeader.realDataOffset + _centralHeader.compressedSize;\n            // no descriptor after compressed data, instead new local header\n            if (input.readUInt32LE(dataEndOffset) == Constants.LOCSIG || input.readUInt32LE(dataEndOffset) == Constants.CENSIG) {\n                throw Utils.Errors.DESCRIPTOR_NOT_EXIST();\n            }\n\n            // get decriptor data\n            if (input.readUInt32LE(dataEndOffset) == Constants.EXTSIG) {\n                // descriptor with signature\n                descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC);\n                descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ);\n                descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN);\n            } else if (input.readUInt16LE(dataEndOffset + 12) === 0x4b50) {\n                // descriptor without signature (we check is new header starting where we expect)\n                descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC - 4);\n                descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ - 4);\n                descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN - 4);\n            } else {\n                throw Utils.Errors.DESCRIPTOR_UNKNOWN();\n            }\n\n            // check data integrity\n            if (descriptor.compressedSize !== _centralHeader.compressedSize || descriptor.size !== _centralHeader.size || descriptor.crc !== _centralHeader.crc) {\n                throw Utils.Errors.DESCRIPTOR_FAULTY();\n            }\n            if (Utils.crc32(data) !== descriptor.crc) {\n                return false;\n            }\n\n            // @TODO: zip64 bit descriptor fields\n            // if bit 3 is set and any value in local header \"zip64 Extended information\" extra field are set 0 (place holder)\n            // then 64-bit descriptor format is used instead of 32-bit\n            // central header - \"zip64 Extended information\" extra field should store real values and not place holders\n        }\n        return true;\n    }\n\n    function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {\n        if (typeof callback === \"undefined\" && typeof async === \"string\") {\n            pass = async;\n            async = void 0;\n        }\n        if (_isDirectory) {\n            if (async && callback) {\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR()); //si added error.\n            }\n            return Buffer.alloc(0);\n        }\n\n        var compressedData = getCompressedDataFromZip();\n\n        if (compressedData.length === 0) {\n            // File is empty, nothing to decompress.\n            if (async && callback) callback(compressedData);\n            return compressedData;\n        }\n\n        if (_centralHeader.encrypted) {\n            if (\"string\" !== typeof pass && !Buffer.isBuffer(pass)) {\n                throw Utils.Errors.INVALID_PASS_PARAM();\n            }\n            compressedData = Methods.ZipCrypto.decrypt(compressedData, _centralHeader, pass);\n        }\n\n        var data = Buffer.alloc(_centralHeader.size);\n\n        switch (_centralHeader.method) {\n            case Utils.Constants.STORED:\n                compressedData.copy(data);\n                if (!crc32OK(data)) {\n                    if (async && callback) callback(data, Utils.Errors.BAD_CRC()); //si added error\n                    throw Utils.Errors.BAD_CRC();\n                } else {\n                    //si added otherwise did not seem to return data.\n                    if (async && callback) callback(data);\n                    return data;\n                }\n            case Utils.Constants.DEFLATED:\n                var inflater = new Methods.Inflater(compressedData, _centralHeader.size);\n                if (!async) {\n                    const result = inflater.inflate(data);\n                    result.copy(data, 0);\n                    if (!crc32OK(data)) {\n                        throw Utils.Errors.BAD_CRC(`\"${decoder.decode(_entryName)}\"`);\n                    }\n                    return data;\n                } else {\n                    inflater.inflateAsync(function (result) {\n                        result.copy(result, 0);\n                        if (callback) {\n                            if (!crc32OK(result)) {\n                                callback(result, Utils.Errors.BAD_CRC()); //si added error\n                            } else {\n                                callback(result);\n                            }\n                        }\n                    });\n                }\n                break;\n            default:\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD());\n                throw Utils.Errors.UNKNOWN_METHOD();\n        }\n    }\n\n    function compress(/*Boolean*/ async, /*Function*/ callback) {\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n            // no data set or the data wasn't changed to require recompression\n            if (async && callback) callback(getCompressedDataFromZip());\n            return getCompressedDataFromZip();\n        }\n\n        if (uncompressedData.length && !_isDirectory) {\n            var compressedData;\n            // Local file header\n            switch (_centralHeader.method) {\n                case Utils.Constants.STORED:\n                    _centralHeader.compressedSize = _centralHeader.size;\n\n                    compressedData = Buffer.alloc(uncompressedData.length);\n                    uncompressedData.copy(compressedData);\n\n                    if (async && callback) callback(compressedData);\n                    return compressedData;\n                default:\n                case Utils.Constants.DEFLATED:\n                    var deflater = new Methods.Deflater(uncompressedData);\n                    if (!async) {\n                        var deflated = deflater.deflate();\n                        _centralHeader.compressedSize = deflated.length;\n                        return deflated;\n                    } else {\n                        deflater.deflateAsync(function (data) {\n                            compressedData = Buffer.alloc(data.length);\n                            _centralHeader.compressedSize = data.length;\n                            data.copy(compressedData);\n                            callback && callback(compressedData);\n                        });\n                    }\n                    deflater = null;\n                    break;\n            }\n        } else if (async && callback) {\n            callback(Buffer.alloc(0));\n        } else {\n            return Buffer.alloc(0);\n        }\n    }\n\n    function readUInt64LE(buffer, offset) {\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n    }\n\n    function parseExtra(data) {\n        try {\n            var offset = 0;\n            var signature, size, part;\n            while (offset + 4 < data.length) {\n                signature = data.readUInt16LE(offset);\n                offset += 2;\n                size = data.readUInt16LE(offset);\n                offset += 2;\n                part = data.slice(offset, offset + size);\n                offset += size;\n                if (Constants.ID_ZIP64 === signature) {\n                    parseZip64ExtendedInformation(part);\n                }\n            }\n        } catch (error) {\n            throw Utils.Errors.EXTRA_FIELD_PARSE_ERROR();\n        }\n    }\n\n    //Override header field values with values from the ZIP64 extra field\n    function parseZip64ExtendedInformation(data) {\n        var size, compressedSize, offset, diskNumStart;\n\n        if (data.length >= Constants.EF_ZIP64_SCOMP) {\n            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n            if (_centralHeader.size === Constants.EF_ZIP64_OR_32) {\n                _centralHeader.size = size;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_RHO) {\n            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n            if (_centralHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n                _centralHeader.compressedSize = compressedSize;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_DSN) {\n            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n            if (_centralHeader.offset === Constants.EF_ZIP64_OR_32) {\n                _centralHeader.offset = offset;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n            if (_centralHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n                _centralHeader.diskNumStart = diskNumStart;\n            }\n        }\n    }\n\n    return {\n        get entryName() {\n            return decoder.decode(_entryName);\n        },\n        get rawEntryName() {\n            return _entryName;\n        },\n        set entryName(val) {\n            _entryName = Utils.toBuffer(val, decoder.encode);\n            var lastChar = _entryName[_entryName.length - 1];\n            _isDirectory = lastChar === 47 || lastChar === 92;\n            _centralHeader.fileNameLength = _entryName.length;\n        },\n\n        get efs() {\n            if (typeof _efs === \"function\") {\n                return _efs(this.entryName);\n            } else {\n                return _efs;\n            }\n        },\n\n        get extra() {\n            return _extra;\n        },\n        set extra(val) {\n            _extra = val;\n            _centralHeader.extraLength = val.length;\n            parseExtra(val);\n        },\n\n        get comment() {\n            return decoder.decode(_comment);\n        },\n        set comment(val) {\n            _comment = Utils.toBuffer(val, decoder.encode);\n            _centralHeader.commentLength = _comment.length;\n            if (_comment.length > 0xffff) throw Utils.Errors.COMMENT_TOO_LONG();\n        },\n\n        get name() {\n            var n = decoder.decode(_entryName);\n            return _isDirectory\n                ? n\n                      .substr(n.length - 1)\n                      .split(\"/\")\n                      .pop()\n                : n.split(\"/\").pop();\n        },\n        get isDirectory() {\n            return _isDirectory;\n        },\n\n        getCompressedData: function () {\n            return compress(false, null);\n        },\n\n        getCompressedDataAsync: function (/*Function*/ callback) {\n            compress(true, callback);\n        },\n\n        setData: function (value) {\n            uncompressedData = Utils.toBuffer(value, Utils.decoder.encode);\n            if (!_isDirectory && uncompressedData.length) {\n                _centralHeader.size = uncompressedData.length;\n                _centralHeader.method = Utils.Constants.DEFLATED;\n                _centralHeader.crc = Utils.crc32(value);\n                _centralHeader.changed = true;\n            } else {\n                // folders and blank files should be stored\n                _centralHeader.method = Utils.Constants.STORED;\n            }\n        },\n\n        getData: function (pass) {\n            if (_centralHeader.changed) {\n                return uncompressedData;\n            } else {\n                return decompress(false, null, pass);\n            }\n        },\n\n        getDataAsync: function (/*Function*/ callback, pass) {\n            if (_centralHeader.changed) {\n                callback(uncompressedData);\n            } else {\n                decompress(true, callback, pass);\n            }\n        },\n\n        set attr(attr) {\n            _centralHeader.attr = attr;\n        },\n        get attr() {\n            return _centralHeader.attr;\n        },\n\n        set header(/*Buffer*/ data) {\n            _centralHeader.loadFromBinary(data);\n        },\n\n        get header() {\n            return _centralHeader;\n        },\n\n        packCentralHeader: function () {\n            _centralHeader.flags_efs = this.efs;\n            _centralHeader.extraLength = _extra.length;\n            // 1. create header (buffer)\n            var header = _centralHeader.centralHeaderToBinary();\n            var addpos = Utils.Constants.CENHDR;\n            // 2. add file name\n            _entryName.copy(header, addpos);\n            addpos += _entryName.length;\n            // 3. add extra data\n            _extra.copy(header, addpos);\n            addpos += _centralHeader.extraLength;\n            // 4. add file comment\n            _comment.copy(header, addpos);\n            return header;\n        },\n\n        packLocalHeader: function () {\n            let addpos = 0;\n            _centralHeader.flags_efs = this.efs;\n            _centralHeader.extraLocalLength = _extralocal.length;\n            // 1. construct local header Buffer\n            const localHeaderBuf = _centralHeader.localHeaderToBinary();\n            // 2. localHeader - crate header buffer\n            const localHeader = Buffer.alloc(localHeaderBuf.length + _entryName.length + _centralHeader.extraLocalLength);\n            // 2.1 add localheader\n            localHeaderBuf.copy(localHeader, addpos);\n            addpos += localHeaderBuf.length;\n            // 2.2 add file name\n            _entryName.copy(localHeader, addpos);\n            addpos += _entryName.length;\n            // 2.3 add extra field\n            _extralocal.copy(localHeader, addpos);\n            addpos += _extralocal.length;\n\n            return localHeader;\n        },\n\n        toJSON: function () {\n            const bytes = function (nr) {\n                return \"<\" + ((nr && nr.length + \" bytes buffer\") || \"null\") + \">\";\n            };\n\n            return {\n                entryName: this.entryName,\n                name: this.name,\n                comment: this.comment,\n                isDirectory: this.isDirectory,\n                header: _centralHeader.toJSON(),\n                compressedData: bytes(input),\n                data: bytes(uncompressedData)\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n","const ZipEntry = require(\"./zipEntry\");\nconst Headers = require(\"./headers\");\nconst Utils = require(\"./util\");\n\nmodule.exports = function (/*Buffer|null*/ inBuffer, /** object */ options) {\n    var entryList = [],\n        entryTable = {},\n        _comment = Buffer.alloc(0),\n        mainHeader = new Headers.MainHeader(),\n        loadedEntries = false;\n    var password = null;\n    const temporary = new Set();\n\n    // assign options\n    const opts = options;\n\n    const { noSort, decoder } = opts;\n\n    if (inBuffer) {\n        // is a memory buffer\n        readMainHeader(opts.readEntries);\n    } else {\n        // none. is a new file\n        loadedEntries = true;\n    }\n\n    function makeTemporaryFolders() {\n        const foldersList = new Set();\n\n        // Make list of all folders in file\n        for (const elem of Object.keys(entryTable)) {\n            const elements = elem.split(\"/\");\n            elements.pop(); // filename\n            if (!elements.length) continue; // no folders\n            for (let i = 0; i < elements.length; i++) {\n                const sub = elements.slice(0, i + 1).join(\"/\") + \"/\";\n                foldersList.add(sub);\n            }\n        }\n\n        // create missing folders as temporary\n        for (const elem of foldersList) {\n            if (!(elem in entryTable)) {\n                const tempfolder = new ZipEntry(opts);\n                tempfolder.entryName = elem;\n                tempfolder.attr = 0x10;\n                tempfolder.temporary = true;\n                entryList.push(tempfolder);\n                entryTable[tempfolder.entryName] = tempfolder;\n                temporary.add(tempfolder);\n            }\n        }\n    }\n\n    function readEntries() {\n        loadedEntries = true;\n        entryTable = {};\n        if (mainHeader.diskEntries > (inBuffer.length - mainHeader.offset) / Utils.Constants.CENHDR) {\n            throw Utils.Errors.DISK_ENTRY_TOO_LARGE();\n        }\n        entryList = new Array(mainHeader.diskEntries); // total number of entries\n        var index = mainHeader.offset; // offset of first CEN header\n        for (var i = 0; i < entryList.length; i++) {\n            var tmp = index,\n                entry = new ZipEntry(opts, inBuffer);\n            entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));\n\n            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));\n\n            if (entry.header.extraLength) {\n                entry.extra = inBuffer.slice(tmp, (tmp += entry.header.extraLength));\n            }\n\n            if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n\n            index += entry.header.centralHeaderSize;\n\n            entryList[i] = entry;\n            entryTable[entry.entryName] = entry;\n        }\n        temporary.clear();\n        makeTemporaryFolders();\n    }\n\n    function readMainHeader(/*Boolean*/ readNow) {\n        var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\n            max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length\n            n = max,\n            endStart = inBuffer.length,\n            endOffset = -1, // Start offset of the END header\n            commentEnd = 0;\n\n        // option to search header form entire file\n        const trailingSpace = typeof opts.trailingSpace === \"boolean\" ? opts.trailingSpace : false;\n        if (trailingSpace) max = 0;\n\n        for (i; i >= n; i--) {\n            if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n                // \"PK\\005\\006\"\n                endOffset = i;\n                commentEnd = i;\n                endStart = i + Utils.Constants.ENDHDR;\n                // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n                n = i - Utils.Constants.END64HDR;\n                continue;\n            }\n\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n                // Found a zip64 signature, let's continue reading the whole zip64 record\n                n = max;\n                continue;\n            }\n\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {\n                // Found the zip64 record, let's determine it's size\n                endOffset = i;\n                endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n                break;\n            }\n        }\n\n        if (endOffset == -1) throw Utils.Errors.INVALID_FORMAT();\n\n        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n        if (mainHeader.commentLength) {\n            _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n        }\n        if (readNow) readEntries();\n    }\n\n    function sortEntries() {\n        if (entryList.length > 1 && !noSort) {\n            entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));\n        }\n    }\n\n    return {\n        /**\n         * Returns an array of ZipEntry objects existent in the current opened archive\n         * @return Array\n         */\n        get entries() {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryList.filter((e) => !temporary.has(e));\n        },\n\n        /**\n         * Archive comment\n         * @return {String}\n         */\n        get comment() {\n            return decoder.decode(_comment);\n        },\n        set comment(val) {\n            _comment = Utils.toBuffer(val, decoder.encode);\n            mainHeader.commentLength = _comment.length;\n        },\n\n        getEntryCount: function () {\n            if (!loadedEntries) {\n                return mainHeader.diskEntries;\n            }\n\n            return entryList.length;\n        },\n\n        forEach: function (callback) {\n            this.entries.forEach(callback);\n        },\n\n        /**\n         * Returns a reference to the entry with the given name or null if entry is inexistent\n         *\n         * @param entryName\n         * @return ZipEntry\n         */\n        getEntry: function (/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryTable[entryName] || null;\n        },\n\n        /**\n         * Adds the given entry to the entry list\n         *\n         * @param entry\n         */\n        setEntry: function (/*ZipEntry*/ entry) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            entryList.push(entry);\n            entryTable[entry.entryName] = entry;\n            mainHeader.totalEntries = entryList.length;\n        },\n\n        /**\n         * Removes the file with the given name from the entry list.\n         *\n         * If the entry is a directory, then all nested files and directories will be removed\n         * @param entryName\n         * @returns {void}\n         */\n        deleteFile: function (/*String*/ entryName, withsubfolders = true) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            const entry = entryTable[entryName];\n            const list = this.getEntryChildren(entry, withsubfolders).map((child) => child.entryName);\n\n            list.forEach(this.deleteEntry);\n        },\n\n        /**\n         * Removes the entry with the given name from the entry list.\n         *\n         * @param {string} entryName\n         * @returns {void}\n         */\n        deleteEntry: function (/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            const entry = entryTable[entryName];\n            const index = entryList.indexOf(entry);\n            if (index >= 0) {\n                entryList.splice(index, 1);\n                delete entryTable[entryName];\n                mainHeader.totalEntries = entryList.length;\n            }\n        },\n\n        /**\n         *  Iterates and returns all nested files and directories of the given entry\n         *\n         * @param entry\n         * @return Array\n         */\n        getEntryChildren: function (/*ZipEntry*/ entry, subfolders = true) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            if (typeof entry === \"object\") {\n                if (entry.isDirectory && subfolders) {\n                    const list = [];\n                    const name = entry.entryName;\n\n                    for (const zipEntry of entryList) {\n                        if (zipEntry.entryName.startsWith(name)) {\n                            list.push(zipEntry);\n                        }\n                    }\n                    return list;\n                } else {\n                    return [entry];\n                }\n            }\n            return [];\n        },\n\n        /**\n         *  How many child elements entry has\n         *\n         * @param {ZipEntry} entry\n         * @return {integer}\n         */\n        getChildCount: function (entry) {\n            if (entry && entry.isDirectory) {\n                const list = this.getEntryChildren(entry);\n                return list.includes(entry) ? list.length - 1 : list.length;\n            }\n            return 0;\n        },\n\n        /**\n         * Returns the zip file\n         *\n         * @return Buffer\n         */\n        compressToBuffer: function () {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            sortEntries();\n\n            const dataBlock = [];\n            const headerBlocks = [];\n            let totalSize = 0;\n            let dindex = 0;\n\n            mainHeader.size = 0;\n            mainHeader.offset = 0;\n            let totalEntries = 0;\n\n            for (const entry of this.entries) {\n                // compress data and set local and entry header accordingly. Reason why is called first\n                const compressedData = entry.getCompressedData();\n                entry.header.offset = dindex;\n\n                // 1. construct local header\n                const localHeader = entry.packLocalHeader();\n\n                // 2. offsets\n                const dataLength = localHeader.length + compressedData.length;\n                dindex += dataLength;\n\n                // 3. store values in sequence\n                dataBlock.push(localHeader);\n                dataBlock.push(compressedData);\n\n                // 4. construct central header\n                const centralHeader = entry.packCentralHeader();\n                headerBlocks.push(centralHeader);\n                // 5. update main header\n                mainHeader.size += centralHeader.length;\n                totalSize += dataLength + centralHeader.length;\n                totalEntries++;\n            }\n\n            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n            // point to end of data and beginning of central directory first record\n            mainHeader.offset = dindex;\n            mainHeader.totalEntries = totalEntries;\n\n            dindex = 0;\n            const outBuffer = Buffer.alloc(totalSize);\n            // write data blocks\n            for (const content of dataBlock) {\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n\n            // write central directory entries\n            for (const content of headerBlocks) {\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n\n            // write main header\n            const mh = mainHeader.toBinary();\n            if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n            }\n            mh.copy(outBuffer, dindex);\n\n            // Since we update entry and main header offsets,\n            // they are no longer valid and we have to reset content\n            // (Issue 64)\n\n            inBuffer = outBuffer;\n            loadedEntries = false;\n\n            return outBuffer;\n        },\n\n        toAsyncBuffer: function (/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {\n            try {\n                if (!loadedEntries) {\n                    readEntries();\n                }\n                sortEntries();\n\n                const dataBlock = [];\n                const centralHeaders = [];\n                let totalSize = 0;\n                let dindex = 0;\n                let totalEntries = 0;\n\n                mainHeader.size = 0;\n                mainHeader.offset = 0;\n\n                const compress2Buffer = function (entryLists) {\n                    if (entryLists.length > 0) {\n                        const entry = entryLists.shift();\n                        const name = entry.entryName + entry.extra.toString();\n                        if (onItemStart) onItemStart(name);\n                        entry.getCompressedDataAsync(function (compressedData) {\n                            if (onItemEnd) onItemEnd(name);\n                            entry.header.offset = dindex;\n\n                            // 1. construct local header\n                            const localHeader = entry.packLocalHeader();\n\n                            // 2. offsets\n                            const dataLength = localHeader.length + compressedData.length;\n                            dindex += dataLength;\n\n                            // 3. store values in sequence\n                            dataBlock.push(localHeader);\n                            dataBlock.push(compressedData);\n\n                            // central header\n                            const centalHeader = entry.packCentralHeader();\n                            centralHeaders.push(centalHeader);\n                            mainHeader.size += centalHeader.length;\n                            totalSize += dataLength + centalHeader.length;\n                            totalEntries++;\n\n                            compress2Buffer(entryLists);\n                        });\n                    } else {\n                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n                        // point to end of data and beginning of central directory first record\n                        mainHeader.offset = dindex;\n                        mainHeader.totalEntries = totalEntries;\n\n                        dindex = 0;\n                        const outBuffer = Buffer.alloc(totalSize);\n                        dataBlock.forEach(function (content) {\n                            content.copy(outBuffer, dindex); // write data blocks\n                            dindex += content.length;\n                        });\n                        centralHeaders.forEach(function (content) {\n                            content.copy(outBuffer, dindex); // write central directory entries\n                            dindex += content.length;\n                        });\n\n                        const mh = mainHeader.toBinary();\n                        if (_comment) {\n                            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n                        }\n\n                        mh.copy(outBuffer, dindex); // write main header\n\n                        // Since we update entry and main header offsets, they are no\n                        // longer valid and we have to reset content using our new buffer\n                        // (Issue 64)\n\n                        inBuffer = outBuffer;\n                        loadedEntries = false;\n\n                        onSuccess(outBuffer);\n                    }\n                };\n\n                compress2Buffer(Array.from(this.entries));\n            } catch (e) {\n                onFail(e);\n            }\n        }\n    };\n};\n","const Utils = require(\"./util\");\nconst pth = require(\"path\");\nconst ZipEntry = require(\"./zipEntry\");\nconst ZipFile = require(\"./zipFile\");\n\nconst get_Bool = (...val) => Utils.findLast(val, (c) => typeof c === \"boolean\");\nconst get_Str = (...val) => Utils.findLast(val, (c) => typeof c === \"string\");\nconst get_Fun = (...val) => Utils.findLast(val, (c) => typeof c === \"function\");\n\nconst defaultOptions = {\n    // option \"noSort\" : if true it disables files sorting\n    noSort: false,\n    // read entries during load (initial loading may be slower)\n    readEntries: false,\n    // default method is none\n    method: Utils.Constants.NONE,\n    // file system\n    fs: null\n};\n\nmodule.exports = function (/**String*/ input, /** object */ options) {\n    let inBuffer = null;\n\n    // create object based default options, allowing them to be overwritten\n    const opts = Object.assign(Object.create(null), defaultOptions);\n\n    // test input variable\n    if (input && \"object\" === typeof input) {\n        // if value is not buffer we accept it to be object with options\n        if (!(input instanceof Uint8Array)) {\n            Object.assign(opts, input);\n            input = opts.input ? opts.input : undefined;\n            if (opts.input) delete opts.input;\n        }\n\n        // if input is buffer\n        if (Buffer.isBuffer(input)) {\n            inBuffer = input;\n            opts.method = Utils.Constants.BUFFER;\n            input = undefined;\n        }\n    }\n\n    // assign options\n    Object.assign(opts, options);\n\n    // instanciate utils filesystem\n    const filetools = new Utils(opts);\n\n    if (typeof opts.decoder !== \"object\" || typeof opts.decoder.encode !== \"function\" || typeof opts.decoder.decode !== \"function\") {\n        opts.decoder = Utils.decoder;\n    }\n\n    // if input is file name we retrieve its content\n    if (input && \"string\" === typeof input) {\n        // load zip file\n        if (filetools.fs.existsSync(input)) {\n            opts.method = Utils.Constants.FILE;\n            opts.filename = input;\n            inBuffer = filetools.fs.readFileSync(input);\n        } else {\n            throw Utils.Errors.INVALID_FILENAME();\n        }\n    }\n\n    // create variable\n    const _zip = new ZipFile(inBuffer, opts);\n\n    const { canonical, sanitize, zipnamefix } = Utils;\n\n    function getEntry(/**Object*/ entry) {\n        if (entry && _zip) {\n            var item;\n            // If entry was given as a file name\n            if (typeof entry === \"string\") item = _zip.getEntry(pth.posix.normalize(entry));\n            // if entry was given as a ZipEntry object\n            if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n\n            if (item) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    function fixPath(zipPath) {\n        const { join, normalize, sep } = pth.posix;\n        // convert windows file separators and normalize\n        return join(\".\", normalize(sep + zipPath.split(\"\\\\\").join(sep) + sep));\n    }\n\n    function filenameFilter(filterfn) {\n        if (filterfn instanceof RegExp) {\n            // if filter is RegExp wrap it\n            return (function (rx) {\n                return function (filename) {\n                    return rx.test(filename);\n                };\n            })(filterfn);\n        } else if (\"function\" !== typeof filterfn) {\n            // if filter is not function we will replace it\n            return () => true;\n        }\n        return filterfn;\n    }\n\n    // keep last character on folders\n    const relativePath = (local, entry) => {\n        let lastChar = entry.slice(-1);\n        lastChar = lastChar === filetools.sep ? filetools.sep : \"\";\n        return pth.relative(local, entry) + lastChar;\n    };\n\n    return {\n        /**\n         * Extracts the given entry from the archive and returns the content as a Buffer object\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @param {Buffer|string} [pass] - password\n         * @return Buffer or Null in case of error\n         */\n        readFile: function (entry, pass) {\n            var item = getEntry(entry);\n            return (item && item.getData(pass)) || null;\n        },\n\n        /**\n         * Returns how many child elements has on entry (directories) on files it is always 0\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @returns {integer}\n         */\n        childCount: function (entry) {\n            const item = getEntry(entry);\n            if (item) {\n                return _zip.getChildCount(item);\n            }\n        },\n\n        /**\n         * Asynchronous readFile\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @param {callback} callback\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFileAsync: function (entry, callback) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(callback);\n            } else {\n                callback(null, \"getEntry failed for:\" + entry);\n            }\n        },\n\n        /**\n         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n         * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry\n         * @param {string} encoding - Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsText: function (entry, encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                var data = item.getData();\n                if (data && data.length) {\n                    return data.toString(encoding || \"utf8\");\n                }\n            }\n            return \"\";\n        },\n\n        /**\n         * Asynchronous readAsText\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @param {callback} callback\n         * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsTextAsync: function (entry, callback, encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(function (data, err) {\n                    if (err) {\n                        callback(data, err);\n                        return;\n                    }\n\n                    if (data && data.length) {\n                        callback(data.toString(encoding || \"utf8\"));\n                    } else {\n                        callback(\"\");\n                    }\n                });\n            } else {\n                callback(\"\");\n            }\n        },\n\n        /**\n         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n         *\n         * @param {ZipEntry|string} entry\n         * @returns {void}\n         */\n        deleteFile: function (entry, withsubfolders = true) {\n            // @TODO: test deleteFile\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteFile(item.entryName, withsubfolders);\n            }\n        },\n\n        /**\n         * Remove the entry from the file or directory without affecting any nested entries\n         *\n         * @param {ZipEntry|string} entry\n         * @returns {void}\n         */\n        deleteEntry: function (entry) {\n            // @TODO: test deleteEntry\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteEntry(item.entryName);\n            }\n        },\n\n        /**\n         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n         *\n         * @param {string} comment\n         */\n        addZipComment: function (comment) {\n            // @TODO: test addZipComment\n            _zip.comment = comment;\n        },\n\n        /**\n         * Returns the zip comment\n         *\n         * @return String\n         */\n        getZipComment: function () {\n            return _zip.comment || \"\";\n        },\n\n        /**\n         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n         * The comment cannot exceed 65535 characters in length\n         *\n         * @param {ZipEntry} entry\n         * @param {string} comment\n         */\n        addZipEntryComment: function (entry, comment) {\n            var item = getEntry(entry);\n            if (item) {\n                item.comment = comment;\n            }\n        },\n\n        /**\n         * Returns the comment of the specified entry\n         *\n         * @param {ZipEntry} entry\n         * @return String\n         */\n        getZipEntryComment: function (entry) {\n            var item = getEntry(entry);\n            if (item) {\n                return item.comment || \"\";\n            }\n            return \"\";\n        },\n\n        /**\n         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n         *\n         * @param {ZipEntry} entry\n         * @param {Buffer} content\n         */\n        updateFile: function (entry, content) {\n            var item = getEntry(entry);\n            if (item) {\n                item.setData(content);\n            }\n        },\n\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param {string} localPath File to add to zip\n         * @param {string} [zipPath] Optional path inside the zip\n         * @param {string} [zipName] Optional name for the file\n         * @param {string} [comment] Optional file comment\n         */\n        addLocalFile: function (localPath, zipPath, zipName, comment) {\n            if (filetools.fs.existsSync(localPath)) {\n                // fix ZipPath\n                zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n                // p - local file name\n                const p = pth.win32.basename(pth.win32.normalize(localPath));\n\n                // add file name into zippath\n                zipPath += zipName ? zipName : p;\n\n                // read file attributes\n                const _attr = filetools.fs.statSync(localPath);\n\n                // get file content\n                const data = _attr.isFile() ? filetools.fs.readFileSync(localPath) : Buffer.alloc(0);\n\n                // if folder\n                if (_attr.isDirectory()) zipPath += filetools.sep;\n\n                // add file into zip file\n                this.addFile(zipPath, data, comment, _attr);\n            } else {\n                throw Utils.Errors.FILE_NOT_FOUND(localPath);\n            }\n        },\n\n        /**\n         * Callback for showing if everything was done.\n         *\n         * @callback doneCallback\n         * @param {Error} err - Error object\n         * @param {boolean} done - was request fully completed\n         */\n\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param {(object|string)} options - options object, if it is string it us used as localPath.\n         * @param {string} options.localPath - Local path to the file.\n         * @param {string} [options.comment] - Optional file comment.\n         * @param {string} [options.zipPath] - Optional path inside the zip\n         * @param {string} [options.zipName] - Optional name for the file\n         * @param {doneCallback} callback - The callback that handles the response.\n         */\n        addLocalFileAsync: function (options, callback) {\n            options = typeof options === \"object\" ? options : { localPath: options };\n            const localPath = pth.resolve(options.localPath);\n            const { comment } = options;\n            let { zipPath, zipName } = options;\n            const self = this;\n\n            filetools.fs.stat(localPath, function (err, stats) {\n                if (err) return callback(err, false);\n                // fix ZipPath\n                zipPath = zipPath ? fixPath(zipPath) : \"\";\n                // p - local file name\n                const p = pth.win32.basename(pth.win32.normalize(localPath));\n                // add file name into zippath\n                zipPath += zipName ? zipName : p;\n\n                if (stats.isFile()) {\n                    filetools.fs.readFile(localPath, function (err, data) {\n                        if (err) return callback(err, false);\n                        self.addFile(zipPath, data, comment, stats);\n                        return setImmediate(callback, undefined, true);\n                    });\n                } else if (stats.isDirectory()) {\n                    zipPath += filetools.sep;\n                    self.addFile(zipPath, Buffer.alloc(0), comment, stats);\n                    return setImmediate(callback, undefined, true);\n                }\n            });\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param {string} localPath - local path to the folder\n         * @param {string} [zipPath] - optional path inside zip\n         * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.\n         */\n        addLocalFolder: function (localPath, zipPath, filter) {\n            // Prepare filter\n            filter = filenameFilter(filter);\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\n            if (filetools.fs.existsSync(localPath)) {\n                const items = filetools.findFiles(localPath);\n                const self = this;\n\n                if (items.length) {\n                    for (const filepath of items) {\n                        const p = pth.join(zipPath, relativePath(localPath, filepath));\n                        if (filter(p)) {\n                            self.addLocalFile(filepath, pth.dirname(p));\n                        }\n                    }\n                }\n            } else {\n                throw Utils.Errors.FILE_NOT_FOUND(localPath);\n            }\n        },\n\n        /**\n         * Asynchronous addLocalFolder\n         * @param {string} localPath\n         * @param {callback} callback\n         * @param {string} [zipPath] optional path inside zip\n         * @param {RegExp|function} [filter] optional RegExp or Function if files match will\n         *               be included.\n         */\n        addLocalFolderAsync: function (localPath, callback, zipPath, filter) {\n            // Prepare filter\n            filter = filenameFilter(filter);\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\n            var self = this;\n            filetools.fs.open(localPath, \"r\", function (err) {\n                if (err && err.code === \"ENOENT\") {\n                    callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath));\n                } else if (err) {\n                    callback(undefined, err);\n                } else {\n                    var items = filetools.findFiles(localPath);\n                    var i = -1;\n\n                    var next = function () {\n                        i += 1;\n                        if (i < items.length) {\n                            var filepath = items[i];\n                            var p = relativePath(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n                            p = p\n                                .normalize(\"NFD\")\n                                .replace(/[\\u0300-\\u036f]/g, \"\")\n                                .replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix\n                            if (filter(p)) {\n                                filetools.fs.stat(filepath, function (er0, stats) {\n                                    if (er0) callback(undefined, er0);\n                                    if (stats.isFile()) {\n                                        filetools.fs.readFile(filepath, function (er1, data) {\n                                            if (er1) {\n                                                callback(undefined, er1);\n                                            } else {\n                                                self.addFile(zipPath + p, data, \"\", stats);\n                                                next();\n                                            }\n                                        });\n                                    } else {\n                                        self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n                                        next();\n                                    }\n                                });\n                            } else {\n                                process.nextTick(() => {\n                                    next();\n                                });\n                            }\n                        } else {\n                            callback(true, undefined);\n                        }\n                    };\n\n                    next();\n                }\n            });\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param {object | string} options - options object, if it is string it us used as localPath.\n         * @param {string} options.localPath - Local path to the folder.\n         * @param {string} [options.zipPath] - optional path inside zip.\n         * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.\n         * @param {function|string} [options.namefix] - optional function to help fix filename\n         * @param {doneCallback} callback - The callback that handles the response.\n         *\n         */\n        addLocalFolderAsync2: function (options, callback) {\n            const self = this;\n            options = typeof options === \"object\" ? options : { localPath: options };\n            localPath = pth.resolve(fixPath(options.localPath));\n            let { zipPath, filter, namefix } = options;\n\n            if (filter instanceof RegExp) {\n                filter = (function (rx) {\n                    return function (filename) {\n                        return rx.test(filename);\n                    };\n                })(filter);\n            } else if (\"function\" !== typeof filter) {\n                filter = function () {\n                    return true;\n                };\n            }\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // Check Namefix function\n            if (namefix == \"latin1\") {\n                namefix = (str) =>\n                    str\n                        .normalize(\"NFD\")\n                        .replace(/[\\u0300-\\u036f]/g, \"\")\n                        .replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix (latin1 characers only)\n            }\n\n            if (typeof namefix !== \"function\") namefix = (str) => str;\n\n            // internal, create relative path + fix the name\n            const relPathFix = (entry) => pth.join(zipPath, namefix(relativePath(localPath, entry)));\n            const fileNameFix = (entry) => pth.win32.basename(pth.win32.normalize(namefix(entry)));\n\n            filetools.fs.open(localPath, \"r\", function (err) {\n                if (err && err.code === \"ENOENT\") {\n                    callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath));\n                } else if (err) {\n                    callback(undefined, err);\n                } else {\n                    filetools.findFilesAsync(localPath, function (err, fileEntries) {\n                        if (err) return callback(err);\n                        fileEntries = fileEntries.filter((dir) => filter(relPathFix(dir)));\n                        if (!fileEntries.length) callback(undefined, false);\n\n                        setImmediate(\n                            fileEntries.reverse().reduce(function (next, entry) {\n                                return function (err, done) {\n                                    if (err || done === false) return setImmediate(next, err, false);\n\n                                    self.addLocalFileAsync(\n                                        {\n                                            localPath: entry,\n                                            zipPath: pth.dirname(relPathFix(entry)),\n                                            zipName: fileNameFix(entry)\n                                        },\n                                        next\n                                    );\n                                };\n                            }, callback)\n                        );\n                    });\n                }\n            });\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param {string} localPath - path where files will be extracted\n         * @param {object} props - optional properties\n         * @param {string} [props.zipPath] - optional path inside zip\n         * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.\n         * @param {function|string} [props.namefix] - optional function to help fix filename\n         */\n        addLocalFolderPromise: function (localPath, props) {\n            return new Promise((resolve, reject) => {\n                this.addLocalFolderAsync2(Object.assign({ localPath }, props), (err, done) => {\n                    if (err) reject(err);\n                    if (done) resolve(this);\n                });\n            });\n        },\n\n        /**\n         * Allows you to create a entry (file or directory) in the zip file.\n         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n         * Comment and attributes are optional\n         *\n         * @param {string} entryName\n         * @param {Buffer | string} content - file content as buffer or utf8 coded string\n         * @param {string} [comment] - file comment\n         * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object\n         */\n        addFile: function (entryName, content, comment, attr) {\n            entryName = zipnamefix(entryName);\n            let entry = getEntry(entryName);\n            const update = entry != null;\n\n            // prepare new entry\n            if (!update) {\n                entry = new ZipEntry(opts);\n                entry.entryName = entryName;\n            }\n            entry.comment = comment || \"\";\n\n            const isStat = \"object\" === typeof attr && attr instanceof filetools.fs.Stats;\n\n            // last modification time from file stats\n            if (isStat) {\n                entry.header.time = attr.mtime;\n            }\n\n            // Set file attribute\n            var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)\n\n            // extended attributes field for Unix\n            // set file type either S_IFDIR / S_IFREG\n            let unix = entry.isDirectory ? 0x4000 : 0x8000;\n\n            if (isStat) {\n                // File attributes from file stats\n                unix |= 0xfff & attr.mode;\n            } else if (\"number\" === typeof attr) {\n                // attr from given attr values\n                unix |= 0xfff & attr;\n            } else {\n                // Default values:\n                unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)\n            }\n\n            fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes\n\n            entry.attr = fileattr;\n\n            entry.setData(content);\n            if (!update) _zip.setEntry(entry);\n\n            return entry;\n        },\n\n        /**\n         * Returns an array of ZipEntry objects representing the files and folders inside the archive\n         *\n         * @param {string} [password]\n         * @returns Array\n         */\n        getEntries: function (password) {\n            _zip.password = password;\n            return _zip ? _zip.entries : [];\n        },\n\n        /**\n         * Returns a ZipEntry object representing the file or folder specified by ``name``.\n         *\n         * @param {string} name\n         * @return ZipEntry\n         */\n        getEntry: function (/**String*/ name) {\n            return getEntry(name);\n        },\n\n        getEntryCount: function () {\n            return _zip.getEntryCount();\n        },\n\n        forEach: function (callback) {\n            return _zip.forEach(callback);\n        },\n\n        /**\n         * Extracts the given entry to the given targetPath\n         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n         *\n         * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry\n         * @param {string} targetPath - Target folder where to write the file\n         * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE\n         * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.\n         * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.\n         * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)\n         *\n         * @return Boolean\n         */\n        extractEntryTo: function (entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {\n            overwrite = get_Bool(false, overwrite);\n            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n            maintainEntryPath = get_Bool(true, maintainEntryPath);\n            outFileName = get_Str(keepOriginalPermission, outFileName);\n\n            var item = getEntry(entry);\n            if (!item) {\n                throw Utils.Errors.NO_ENTRY();\n            }\n\n            var entryName = canonical(item.entryName);\n\n            var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));\n\n            if (item.isDirectory) {\n                var children = _zip.getEntryChildren(item);\n                children.forEach(function (child) {\n                    if (child.isDirectory) return;\n                    var content = child.getData();\n                    if (!content) {\n                        throw Utils.Errors.CANT_EXTRACT_FILE();\n                    }\n                    var name = canonical(child.entryName);\n                    var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));\n                    // The reverse operation for attr depend on method addFile()\n                    const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;\n                    filetools.writeFileTo(childName, content, overwrite, fileAttr);\n                });\n                return true;\n            }\n\n            var content = item.getData(_zip.password);\n            if (!content) throw Utils.Errors.CANT_EXTRACT_FILE();\n\n            if (filetools.fs.existsSync(target) && !overwrite) {\n                throw Utils.Errors.CANT_OVERRIDE();\n            }\n            // The reverse operation for attr depend on method addFile()\n            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n            filetools.writeFileTo(target, content, overwrite, fileAttr);\n\n            return true;\n        },\n\n        /**\n         * Test the archive\n         * @param {string} [pass]\n         */\n        test: function (pass) {\n            if (!_zip) {\n                return false;\n            }\n\n            for (var entry in _zip.entries) {\n                try {\n                    if (entry.isDirectory) {\n                        continue;\n                    }\n                    var content = _zip.entries[entry].getData(pass);\n                    if (!content) {\n                        return false;\n                    }\n                } catch (err) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Extracts the entire archive to the given location\n         *\n         * @param {string} targetPath Target location\n         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param {string|Buffer} [pass] password\n         */\n        extractAllTo: function (targetPath, overwrite, keepOriginalPermission, pass) {\n            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n            pass = get_Str(keepOriginalPermission, pass);\n            overwrite = get_Bool(false, overwrite);\n            if (!_zip) throw Utils.Errors.NO_ZIP();\n\n            _zip.entries.forEach(function (entry) {\n                var entryName = sanitize(targetPath, canonical(entry.entryName));\n                if (entry.isDirectory) {\n                    filetools.makeDir(entryName);\n                    return;\n                }\n                var content = entry.getData(pass);\n                if (!content) {\n                    throw Utils.Errors.CANT_EXTRACT_FILE();\n                }\n                // The reverse operation for attr depend on method addFile()\n                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                filetools.writeFileTo(entryName, content, overwrite, fileAttr);\n                try {\n                    filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);\n                } catch (err) {\n                    throw Utils.Errors.CANT_EXTRACT_FILE();\n                }\n            });\n        },\n\n        /**\n         * Asynchronous extractAllTo\n         *\n         * @param {string} targetPath Target location\n         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.\n         */\n        extractAllToAsync: function (targetPath, overwrite, keepOriginalPermission, callback) {\n            callback = get_Fun(overwrite, keepOriginalPermission, callback);\n            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n            overwrite = get_Bool(false, overwrite);\n            if (!callback) {\n                return new Promise((resolve, reject) => {\n                    this.extractAllToAsync(targetPath, overwrite, keepOriginalPermission, function (err) {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(this);\n                        }\n                    });\n                });\n            }\n            if (!_zip) {\n                callback(Utils.Errors.NO_ZIP());\n                return;\n            }\n\n            targetPath = pth.resolve(targetPath);\n            // convert entryName to\n            const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName)));\n            const getError = (msg, file) => new Error(msg + ': \"' + file + '\"');\n\n            // separate directories from files\n            const dirEntries = [];\n            const fileEntries = [];\n            _zip.entries.forEach((e) => {\n                if (e.isDirectory) {\n                    dirEntries.push(e);\n                } else {\n                    fileEntries.push(e);\n                }\n            });\n\n            // Create directory entries first synchronously\n            // this prevents race condition and assures folders are there before writing files\n            for (const entry of dirEntries) {\n                const dirPath = getPath(entry);\n                // The reverse operation for attr depend on method addFile()\n                const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                try {\n                    filetools.makeDir(dirPath);\n                    if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);\n                    // in unix timestamp will change if files are later added to folder, but still\n                    filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);\n                } catch (er) {\n                    callback(getError(\"Unable to create folder\", dirPath));\n                }\n            }\n\n            fileEntries.reverse().reduce(function (next, entry) {\n                return function (err) {\n                    if (err) {\n                        next(err);\n                    } else {\n                        const entryName = pth.normalize(canonical(entry.entryName));\n                        const filePath = sanitize(targetPath, entryName);\n                        entry.getDataAsync(function (content, err_1) {\n                            if (err_1) {\n                                next(err_1);\n                            } else if (!content) {\n                                next(Utils.Errors.CANT_EXTRACT_FILE());\n                            } else {\n                                // The reverse operation for attr depend on method addFile()\n                                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                                filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {\n                                    if (!succ) {\n                                        next(getError(\"Unable to write file\", filePath));\n                                    }\n                                    filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {\n                                        if (err_2) {\n                                            next(getError(\"Unable to set times\", filePath));\n                                        } else {\n                                            next();\n                                        }\n                                    });\n                                });\n                            }\n                        });\n                    }\n                };\n            }, callback)();\n        },\n\n        /**\n         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n         *\n         * @param {string} targetFileName\n         * @param {function} callback\n         */\n        writeZip: function (targetFileName, callback) {\n            if (arguments.length === 1) {\n                if (typeof targetFileName === \"function\") {\n                    callback = targetFileName;\n                    targetFileName = \"\";\n                }\n            }\n\n            if (!targetFileName && opts.filename) {\n                targetFileName = opts.filename;\n            }\n            if (!targetFileName) return;\n\n            var zipData = _zip.compressToBuffer();\n            if (zipData) {\n                var ok = filetools.writeFileTo(targetFileName, zipData, true);\n                if (typeof callback === \"function\") callback(!ok ? new Error(\"failed\") : null, \"\");\n            }\n        },\n\n        /**\n         *\n         * @param {string} targetFileName\n         * @param {object} [props]\n         * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.\n         * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.\n\n         * @returns {Promise<void>}\n         */\n        writeZipPromise: function (/**String*/ targetFileName, /* object */ props) {\n            const { overwrite, perm } = Object.assign({ overwrite: true }, props);\n\n            return new Promise((resolve, reject) => {\n                // find file name\n                if (!targetFileName && opts.filename) targetFileName = opts.filename;\n                if (!targetFileName) reject(\"ADM-ZIP: ZIP File Name Missing\");\n\n                this.toBufferPromise().then((zipData) => {\n                    const ret = (done) => (done ? resolve(done) : reject(\"ADM-ZIP: Wasn't able to write zip file\"));\n                    filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);\n                }, reject);\n            });\n        },\n\n        /**\n         * @returns {Promise<Buffer>} A promise to the Buffer.\n         */\n        toBufferPromise: function () {\n            return new Promise((resolve, reject) => {\n                _zip.toAsyncBuffer(resolve, reject);\n            });\n        },\n\n        /**\n         * Returns the content of the entire zip file as a Buffer object\n         *\n         * @prop {function} [onSuccess]\n         * @prop {function} [onFail]\n         * @prop {function} [onItemStart]\n         * @prop {function} [onItemEnd]\n         * @returns {Buffer}\n         */\n        toBuffer: function (onSuccess, onFail, onItemStart, onItemEnd) {\n            if (typeof onSuccess === \"function\") {\n                _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n                return null;\n            }\n            return _zip.compressToBuffer();\n        }\n    };\n};\n"],"names":["errors","exports","require$$0","require$$1","require$$2","require$$3","path","err","fd","utilModule","require$$4","decoder","inflater","deflater","mainHeader","zipEntry","localPath","options","content","fileAttr"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}