{"version":3,"file":"extract-manifest.js","sources":["../src/core/extract-manifest.ts"],"sourcesContent":["/**\n * extract-manifest.ts\n *\n * Loads application manifest from a Fusion application bundle (zip) file\n *\n * This module extracts the app-manifest.json file from the bundle to retrieve\n * the application configuration, particularly the appKey which is essential for\n * deployment and identification purposes.\n *\n * The manifest loading is performant as it uses AdmZip to read directly from\n * the zip without extracting to temporary files.\n */\nimport path from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport * as core from \"@actions/core\";\nimport AdmZip from \"adm-zip\";\n\n/**\n * The shape of the manifest loaded from the bundle zip file.\n * Normally contains more fields, but we only care about appKey here.\n * Used for publish config.\n */\nexport type Manifest = {\n  appKey: string;\n} & Record<string, unknown>;\n\n/**\n * Loads the manifest from a bundle zip file.\n * @param bundle - The AdmZip instance representing the bundle.\n * @returns A promise resolving to an object containing the manifest.\n * @throws If app.manifest.json is missing or cannot be parsed.\n */\nexport const loadManifest = (bundle: AdmZip): Promise<Manifest> => {\n  const manifestEntry =\n    bundle.getEntry(\"app-manifest.json\") ??\n    bundle.getEntries().find((entry) => entry.entryName.endsWith(\"/app-manifest.json\"));\n  if (!manifestEntry) {\n    throw new Error(\"Manifest file not found in bundle\");\n  }\n  return new Promise((resolve, reject) => {\n    manifestEntry.getDataAsync((data, err) => {\n      if (err) {\n        return reject(new Error(\"Failed to read manifest file\", { cause: err }));\n      }\n      try {\n        return resolve(JSON.parse(String(data)));\n      } catch (error) {\n        reject(new Error(\"Failed to parse manifest file\", { cause: error }));\n      }\n    });\n  });\n};\n\nconst isDirectExecution =\n  process.argv[1] && path.resolve(process.argv[1]) === fileURLToPath(import.meta.url);\n\nif (isDirectExecution) {\n  try {\n    const zipPath = process.env.INPUT_ARTIFACT || core.getInput(\"artifact\");\n    const bundle = new AdmZip(zipPath);\n\n    loadManifest(bundle)\n      .then((manifest) => {\n        console.log(JSON.stringify(manifest));\n      })\n      .catch((error) => {\n        const message = error instanceof Error ? error.message : \"Unknown error\";\n        core.error(`Failed to load manifest: ${message}`);\n        process.exit(1);\n      });\n  } catch (error: unknown) {\n    const message = error instanceof Error ? error.message : \"Unknown error\";\n    core.error(`Failed to load manifest: ${message}`);\n    process.exit(1);\n  }\n}\n"],"names":["error","path","core.getInput","core.error"],"mappings":";;;;AAgCO,MAAM,eAAe,CAAC,WAAsC;AACjE,QAAM,gBACJ,OAAO,SAAS,mBAAmB,KACnC,OAAO,WAAA,EAAa,KAAK,CAAC,UAAU,MAAM,UAAU,SAAS,oBAAoB,CAAC;AACpF,MAAI,CAAC,eAAe;AAClB,UAAM,IAAI,MAAM,mCAAmC;AAAA,EACrD;AACA,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,kBAAc,aAAa,CAAC,MAAM,QAAQ;AACxC,UAAI,KAAK;AACP,eAAO,OAAO,IAAI,MAAM,gCAAgC,EAAE,OAAO,IAAA,CAAK,CAAC;AAAA,MACzE;AACA,UAAI;AACF,eAAO,QAAQ,KAAK,MAAM,OAAO,IAAI,CAAC,CAAC;AAAA,MACzC,SAASA,QAAO;AACd,eAAO,IAAI,MAAM,iCAAiC,EAAE,OAAOA,OAAA,CAAO,CAAC;AAAA,MACrE;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AAEA,MAAM,oBACJ,QAAQ,KAAK,CAAC,KAAKC,cAAK,QAAQ,QAAQ,KAAK,CAAC,CAAC,MAAM,cAAc,YAAY,GAAG;AAEpF,IAAI,mBAAmB;AACrB,MAAI;AACF,UAAM,UAAU,QAAQ,IAAI,kBAAkBC,SAAc,UAAU;AACtE,UAAM,SAAS,IAAI,OAAO,OAAO;AAEjC,iBAAa,MAAM,EAChB,KAAK,CAAC,aAAa;AAClB,cAAQ,IAAI,KAAK,UAAU,QAAQ,CAAC;AAAA,IACtC,CAAC,EACA,MAAM,CAACF,YAAU;AAChB,YAAM,UAAUA,mBAAiB,QAAQA,QAAM,UAAU;AACzDG,YAAW,4BAA4B,OAAO,EAAE;AAChD,cAAQ,KAAK,CAAC;AAAA,IAChB,CAAC;AAAA,EACL,SAASH,SAAgB;AACvB,UAAM,UAAUA,mBAAiB,QAAQA,QAAM,UAAU;AACzDG,UAAW,4BAA4B,OAAO,EAAE;AAChD,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;"}